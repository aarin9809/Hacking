## 바이트 오더링(Byte Ordering)
    2 바이트 이상의 데이터는 메모리에 연속적으로 저장. 
    이때 각 바이트가 메모리에 정렬되는 방식을 바이트 오더링(Byte ordering)이라 부름. 
    바이트 오더링의 두 가지 방식으로 빅 엔디안(Big Endian), 리틀 엔디안(Little Endian)이 있습니다. 
    어떤 바이트부터 낮은 주소에 저장되는지에 따라 두 방식을 구분. 
    먼저 이해를 돕기 위해 왼쪽에 있는 바이트일수록 “크다”고 표현.

예를 들어 0x01234567과 같은 데이터가 있을 때, 가장 왼쪽의 0x01이 가장 큰 바이트이고, 
가장 오른쪽의 0x67이 가장 작은 바이트입니다. 빅 엔디안은 큰(Big) 바이트부터 낮은 주소에 저장됩니다. 
반대로 리틀 엔디안은 작은(Little) 바이트부터 낮은 주소에 저장됩니다.

**바이트 오더링은 비트의 순서가 아니라 바이트의 순서를 고려하는 것으로, 
바이트 내 비트의 순서는 동일하고 바이트의 순서만 달라집니다.**

### 빅 엔디안
가장 왼쪽에 있는(큰) 바이트부터 메모리의 낮은 주소에 저장됩니다.
* 네트워크 상에서 데이터를 전송할 때는 빅 엔디안 방식을 따릅니다.
* 대표적으로 SPARC CPU에서 빅 엔디안을 사용합니다.

### 리틀 엔디안
가장 오른쪽에 있는(작은) 바이트부터 메모리의 낮은 주소에 저장됩니다.
* 대표적으로 Intel의 x86, x86_64 CPU에서 리틀 엔디안을 사용합니다. 
대다수의 개인용 컴퓨터 및 서버 환경에서 x86-64 CPU 아키텍처를 사용하고 있는 만큼, 리틀 엔디안 방식을 잘 알고 있어야함.

## 문자열
* str 변수 주소의 메모리를 1 바이트씩 4 바이트 출력한 결과입니다.
* 문자열을 메모리에 저장할 때는 바이트 오더링을 고려하지 않습니다.
* 따라서 문자열 "ABCD"는 리틀 엔디안 방식을 따르지 않고, 문자 순서 그대로 메모리에 저장됩니다.

0x555555556004: 0x41    0x42    0x43    0x44

* 문자열이 아닌 데이터 - 16진수 정수
num 변수 주소의 메모리를 1 바이트씩 4 바이트 출력한 결과입니다. 
문자열이 아닌 데이터는 리틀 엔디안 방식으로 저장됩니다. 
따라서 16진수 0x41424344는 가장 오른쪽의 바이트부터 메모리의 낮은 주소에 저장된 것을 볼 수 있습니다. 
num 변수 값을 출력하면 메모리에 저장된 4 바이트에서 높은 주소부터 읽어 와서 원래 값 그대로 출력됩니다.

