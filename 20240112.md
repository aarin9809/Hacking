# chmod
리눅스에서 File을 사용해 할 수 있는 작업은 크게 세 가지로 나눌 수 있습니다.
1. File에 저장된 Data를 읽기(r = read)
2. File에 Data를 쓰기(w = write)
3. File 실행(x = execute)

그런데 만약 리눅스 시스템의 모든 파일이 그 종류 똔느 쓰임새와 관계없이 읽기, 쓰기, 실행 가능하게 만들어져 있다면 어떻게 될까요?
잘못된 명령어 사용으로 시스템 운영에 중요한 역할을 하는 파일의 내용이 변경되거나, 사용자의 사소한 실수 한번으로 리눅스 시스템의
모든 파일이 삭제될 수도 있습니다.

이런 문제가 생기는 경우를 방지하기 위해, 리눅스에서는 각 파일 및 디렉토리에 대해 **읽기(r) 쓰기(w) 실행(x)** 권한을 파일 개별적으로
지정할 수 있도록 만들어 놓았습니다. 그리고 이 세 가지 권한을 "파일을 소유한 사용자(user)", "특정 그룹(group)에 소속된 사용자",
"그 외 사용자(others)"에 대해 각각 지정할 수 있게 만들었습니다.

**chmod** 명령은 바로 이러한 파일의 권한을 변경할 수 있게 만들어주는 명령어 입니다. "change" + "mode"의 앞글자들을 조합한 이름임.

### **chmod 명령을 사용하여 파일의 모드(mode)를 변경한다는 것은 파일의 권한을 변경한다는 것과 동일한 의미를 가짐.**

#### chmod [option] [mode] [file]
OPTION
* -v    : 모든 파일에 대해 모드가 적용되는 진단 메시지 출력.
* -f    : 에러 메세지 출력하지 않음.
* -c    : 기존 파일 모드가 변경되는 경우만 진단 메시지 출력.
* -R    : 지정한 모드를 파일과 디렉토리에 대해 재귀적으로 적용.
MODE
* u,g,o,a : 소우쟈, 그룹, 그 외 사용자, 모든 사용자 지정. 
* +,-,= : 현재모드에 권한 추가(+), 현재 모드에서 권한 제거(-), 현재 모드로 권한 지정(=) 
* r,w,x : 읽기 권한, 쓰기 권한, 실행 권한
* X : "디렉토리" 또는 "실행 권한이 있는 파일"에 실행 권한(x) 적용
* s : 실행 시 사용자 또는 그룹 ID 지정(s). "setuid", "setgid".
* t : 공유모드에서의 제한된 삭제 플래그를 나타내는 sticky(t) bit.
* 0 ~ 7 : 8진수(octet) 형식 모드 설정 값.

## chmod 명령의 MODE 파라미터.
* 파일을 소유한 **사용자**에 대해 **읽고** **쓸 수** 있는 권한 **지정** --> chmod u=rw FILE
* 파일이 속한 **그룹**이 **실행**할 수 있는 권한 **추가**             --> chmod g+x FILE
* 시스템의 모든 **사용자**가 **읽을 수**만 있는 권한 **지정**.         --> chmod a=r FILE
* 파일을 소유한 **그룹**과 **그 외 사용자**의 모든 권한 **제거**.      --> chmod go-rwx FILE

#### ls -al
    -rw-r--r-- 1 user1 user2 17 Mar 24 03:17 FILE

* 파일 소유 사용자 : user1
* 파일 소유 그룹 : user2
* 파일 소유 사용자(user1)의 권한 : rw-
* 파일 소유 그룹(user2)의 권한 : r--
* 그 외의 권한 : r--

### 디렉토리에 대한 권한
* r 권한은 파일 리스트를 확인할 수 있는 권한을 의미함.(r 권한만 있는경우 파일 이름만 확인 가능하고, 파일의 모든 정보를 확인 하기
위해선 실행(x) 권한이 있어야함.)
* w 권한은 파일을 생성하거나 복사, 이름변경, 삭제 등의 작업을 하고자 할 때 필요한 권한임.
주의할 점은 w권한만 있다고해서 작업이 수행되지않고, x 권한도 같이 지정되어야지만 작업이 정상적으로 수행됨.
* 

## chmod 예제
$ chmod u+x FILE                    # 파일 소유 사용자에게 실행권한 추가.

$ chmod u+w FILE                    # 파일 소유 사용자에게 쓰기 권한 추가.

$ chmod u=rwx FILE                  # 파일 소유 사용자에게 읽기, 쓰기, 실행 권한 지정.

$ chmod u-x FILE                    # 파일 소유 사용자의 실행 권한 제거.

$ chmod g+w FILE                    # 파일 소유 그룹에 쓰기 권한 추가.

$ chmod g-x FILE                    # 파일 소유 그룹의 실행 권한 제거.

$ chmod o=r FILE                    # 파일 소유 사용자 및 그룹을 제외한 사용자는 읽기만 가능.

$ chmod a-x *                       # 현재 디렉토리의 모든 파일에서 모든 사용자의 읽기 권한 제거.

$ chmod a-w FILE                    # 모든 사용자에 대해 쓰기 권한 제거.

$ chmod u=rwx,g=r FILE              # 파일 소유 사용자는 모든 권한, 그룹은 읽기만 가능.

$ chmod ug=rw FILE                  # 파일 소유 사용자와 그룹이 읽기, 쓰기 가능.

$ chmod g=rw,o=r FILE               # 파일 소유 그룹은 읽기, 쓰기 가능, 그 외 사용자는 읽기만 가능.

$ chmod ug=rw,o=r FILE              # 파일 소유 사용자 및 그룹은 일기, 쓰기 가능, 그외 사용자는 읽기만 가능.

$ chmod 000 FILE                    # 모든 사용자의 모든 권한 제거. = ---------

$ chmod 664 FILE                    # 사용자(읽기+쓰기), 그룹(읽기+쓰기), 그외 사용자(읽기) = rw-rw-r--

$ chmod 755 FILE                    # 사용자(읽기+쓰기+실행), 그룹(읽기+실행), 그외 사용자(읽기+실행) = rwxr-xr-x

$ chmod 777 FILE                    # 모든 사용자에 모든 권한 추가.

$ chmod -R g+x DIR                  # DIR 디렉토리 하위 모든 파일 및 디렉토리에 그룹 실행(x) 권한 추가.

$ chmod -R o-wx *                   # 현재 디렉토리의 모든 파일에서 그외 사용자의 쓰기, 실행 권한 제거

$ chmod -R a-x,a+X *                # 현재 디렉토리 기준 모든 파일 읽기 권한 제거, 디렉토리 실행 권한 추가.

$ chmod -R a-x+X *                  # 위(chmod -R a-x,a+X *)와 동일.

$ chmod u=g FILE                    # FILE의 그룹 권한 값을 사용자 권한으로 적용.
$ ls -l
-rwxr--r-- 1 ppotta manager   23 Mar 26 04:13 FILE
$ chmod u=g FILE
-r--r--r-- 1 ppotta manager   23 Mar 26 04:13 FILE

$ chmod u+g FILE                    # FILE의 사용자 권한에 그룹 권한 값을 추가.
$ ls -l
-r-x-w--w- 1 ppotta manager   23 Mar 26 04:13 FILE
$ chmod u+g FILE
-rwx-w--w- 1 ppotta manager   23 Mar 26 04:13 FILE